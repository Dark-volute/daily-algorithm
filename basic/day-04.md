
[https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)


## 单调栈

### 思路

通过题目给的三个例子，应该可以发现一些端倪。

- 如果 arr 是非递减的，那么答案为 1。
- 如果 arr 是非递增的，那么答案是 arr 的长度。

并且由于**只有分的块内部可以排序**，块与块之间的相对位置是不能变的。因此**直观上**我们的核心其实找到从左到右开始不减少（增加或者不变）的地方并分块。

比如对于 [5,4,3,2,1] 来说：

- 5 的下一个是 4，比 5 小，因此如果分块，那么永远不能变成[1,2,3,4,5]。
- 同理，4 的下一个是 3，比 4 小，因此如果分块，那么永远不能变成[1,2,3,4,5]。
- 。。。

最后就是不能只能是整体是一个大块，我们返回 1 即可。

我们继续分析一个稍微复杂一点的，即题目给的 [2,1,3,4,4]。

- 2 的下一个是 1，比 2 小，不能分块。
- 1 的下一个是 3，比 1 大，可以分块。
- 3 的下一个是 4，比 3 大，可以分块。
- 4 的下一个是 4，一样大，可以分块。

因此答案就是 4，分别是：

- [2,1]
- [3]
- [3]
- [4]

然而上面的算法步骤是不正确的，原因在于只考虑局部，没有考虑整体，比如 **[4,2,2,1,1]** 这样的测试用例，实际上只应该返回 1，原因是后面碰得到了 1，使得前面不应该分块。

因为把数组分成数个块，分别排序每个块后，组合所有的块就跟整个数组排序的结果一样，这就意味着后面块中的最小值一定大于前面块的最大值,这样才能保证分块有。因此直观上，我们又会觉得是不是”只要后面有较小值，那么前面大于它的都应该在一个块里面“，实际上的确如此。

有没有注意到我们一直在找下一个比当前小的元素？这就是一个信号，使用单调递增栈即可以空间换时间的方式解决.

不过这还不够，我们要把思路逆转！

这里的话，我们将思路逆转，不是分割区块，而是**融合区块**。

比如 [2,1,3,4,4]，遍历到 1 的时候会发现 1 比 2 小，因此 2， 1 需要在一块，我们可以将 2 和 1 融合，并**重新压回栈**。那么融合成 1 还是 2 呢？答案是 2，因为 2 是瓶颈，这提示我们可以用一个递增栈来完成。

因此本质上**栈存储的每一个元素就代表一个块，而栈里面的每一个元素的值就是块的最大值**。

以 [2,1,3,4,4] 来说， stack 的变化过程大概是：

- [2]
- 1 被融合了，保持 [2] 不变
- [2,3]
- [2,3,4]
- [2,3,4,4]

简单来说，就是**将一个减序列压缩合并成最该序列的最大的值**。 因此最终返回 stack 的长度就可以了。

### 代码
```js
var maxChunksToSorted = function(arr) {
    let stack = []
    let max = -Infinity
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] >= max) {
            stack.push(arr[i])
            max = arr[i]
        } else {
            while (arr[i] < stack[stack.length - 1]) {
                stack.pop()
            }
            stack.push(max)
        }
    }
    return stack.length
};
```
### 复杂度分析

- 时间复杂度：$O(N)$，其中 N 为数组长度。
- 空间复杂度：$O(N)$，其中 N 为数组长度。
